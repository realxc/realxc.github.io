<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"realxc.githut.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"搜索文章","hits_empty":"未找到相关文章: ${query}","hits_stats":"找到${hits}篇文章，用时${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="博客园-向闯">
<meta property="og:url" content="http://realxc.githut.io/page/3/index.html">
<meta property="og:site_name" content="博客园-向闯">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Xiang Chuang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://realxc.githut.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>博客园-向闯</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客园-向闯</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/12/07/mongo-%E6%9F%A5%E8%AF%A2%E6%8A%A5no-property-found-on/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/07/mongo-%E6%9F%A5%E8%AF%A2%E6%8A%A5no-property-found-on/" class="post-title-link" itemprop="url">mongo-查询报no property found on</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-07 15:11:00" itemprop="dateCreated datePublished" datetime="2018-12-07T15:11:00+08:00">2018-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%99%E4%BA%9B%E5%B9%B4%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%9D%91/" itemprop="url" rel="index"><span itemprop="name">这些年，那些坑</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>455</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>No property null found on entity com.yiji.dtrace.core.SpanId to bind constructor parameter to!</p>
<p>现象：线上和本地都没问题，同样的应用同样的数据，就测试环境有问题</p>
<p>如果有自定义转换器走这，没得 就会默认</p>
<p><img src="\images\pasted-6.png" alt="upload successful"></p>
<p><img src="\images\pasted-7.png" alt="upload successful"><br>加载构造函数，这里是通过java8新特性，直接获取到了构造函数的入参名称，然后以此为key获取mongo集合对应的值<br><img src="\images\pasted-8.png" alt="upload successful"></p>
<p><img src="\images\pasted-9.png" alt="upload successful"></p>
<p><img src="\images\pasted-10.png" alt="upload successful"></p>
<p><img src="\images\pasted-11.png" alt="upload successful"><br>根据构造函数的入参获取mongo查出来的值，问题出在constructor.getParameters()获取入参时候， 取得了一个null</p>
<p><img src="\images\pasted-12.png" alt="upload successful"></p>
<p>No property null found on entity com.yiji.dtrace.core.SpanId to bind constructor parameter to!</p>
<p>问题在于：<br>测试环境apm启动时，使用了javaagent代理，代理本身就是apm的，里面也有com.yiji.dtrace.core.SpanId，因此出现了冲突！！！！！</p>
<p>java8通过以下类提供了反射获取方法参数名成的能力</p>
<p><img src="\images\pasted-14.png" alt="upload successful"></p>
<p><img src="\images\pasted-15.png" alt="upload successful"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/11/13/disruptor%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/13/disruptor%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB/" class="post-title-link" itemprop="url">disruptor为什么那么快</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-13 17:05:00" itemprop="dateCreated datePublished" datetime="2018-11-13T17:05:00+08:00">2018-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%88%B1%E5%AD%A6%E7%88%B1%E9%97%AE/" itemprop="url" rel="index"><span itemprop="name">爱学爱问</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>276</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>disruptor可用于线程间数据交互<br>详细参考文章<a target="_blank" rel="noopener" href="http://ifeve.com/disruptor/">http://ifeve.com/disruptor/</a></p>
<p>概述一下为什么那么快（这将有利于你借鉴思想）<br>1、私有序列号，它是AtomicLong类型的，基于CAS（cpu级指令），因此没有锁<br>2、缓存行填充，避免伪共享（一个缓存行64字节，对应8个long）<br>   伪共享：多个线程修改相互独立的变量时，如果它们位于同一个缓存行，则         会影响性能<br>    java8：@Contended（自动填充缓存行），<br>        但需要jvm参数-XX:RestrictContended<br>   注意，缓存行的填充是以存储换性能。。。<br>3、内存屏障 volatile   </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/11/01/Class%E5%8F%8Ajavaagent%E8%A3%85%E8%BD%BD%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/01/Class%E5%8F%8Ajavaagent%E8%A3%85%E8%BD%BD%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">class及javaagent装载简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-01 17:18:00" itemprop="dateCreated datePublished" datetime="2018-11-01T17:18:00+08:00">2018-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%88%B1%E5%AD%A6%E7%88%B1%E9%97%AE/" itemprop="url" rel="index"><span itemprop="name">爱学爱问</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>267</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>场景：有些时候我们想做一个通用的事情，这关系到各个应用系统，如采集应用系统产生的数据，当然，我们不想代码倾入到应用系统中，“偷偷摸摸、神不知鬼不觉”地干这些事，那么，你可以考虑考虑借鉴javaagent的思想在Class类加载期间干点事。</p>
<p><img src="\images\pasted-79.png" alt="upload successful"></p>
<p>javaagent装载阶段预置了transformer<br>class装载阶段读取transformer信息并进行制定的处理</p>
<p>因此，你可以在javaagent中自定义transformer以做你想做的事，如使用bytebuddy代理类（这个代理性能不错，学习成本低，当然如果你熟悉字节码，可以直接asm）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/10/31/javaagent-bytebuddy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/31/javaagent-bytebuddy/" class="post-title-link" itemprop="url">javaagent-bytebuddy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-31 17:01:00" itemprop="dateCreated datePublished" datetime="2018-10-31T17:01:00+08:00">2018-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%96%E9%83%A8%E5%BC%95%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">外部引用</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java agent是在另外一个Java应用（“目标”应用）启动之前要执行的Java程序，这样agent就有机会修改目标应用或者应用所运行的环境。在本文中，我们将会从基础内容开始，逐渐增强其功能，借助字节码操作工具Byte Buddy，使其成为高级的agent实现。</p>
<p>在最基本的用例中，Java agent会用来设置应用属性或者配置特定的环境状态，agent能够作为可重用和可插入的组件。如下的样例描述了这样的一个agent，它设置了一个系统属性，在实际的程序中就可以使用该属性了：</p>
<p>public class Agent {  public static void premain(String arg) {    System.setProperty(“my-property”, “foo”);  }}</p>
<p>如上面的代码所述，Java agent的定义与其他的Java程序类似，只不过它使用premain方法替代main方法作为入口点。顾名思义，这个方法能够在目标应用的main方法之前执行。相对于其他的Java程序，编写agent并没有特定的规则。有一个很小的区别在于，Java agent接受一个可选的参数，而不是包含零个或更多参数的数组。</p>
<p>如果要使用这个agent，必须要将agent类和资源打包到jar中，并且在jar的manifest中要将Agent-Class属性设置为包含premain方法的agent类。（agent必须要打包到jar文件中，它不能通过拆解的格式进行指定。）接下来，我们需要启动应用程序，并且在命令行中通过javaagent参数来引用jar文件的位置：</p>
<p>java -javaagent:myAgent.jar -jar myProgram.jar</p>
<p>我们还可以在位置路径上设置可选的agent参数。在下面的命令中会启动一个Java程序并且添加给定的agent，将值myOptions作为参数提供给premain方法：</p>
<p>java -javaagent:myAgent.jar=myOptions -jar myProgram.jar</p>
<p>通过重复使用javaagent命令，能够添加多个agent。</p>
<p>但是，Java agent的功能并不局限于修改应用程序环境的状态，Java agent能够访问Java instrumentation API，这样的话，agent就能修改目标应用程序的代码。Java虚拟机中这个鲜为人知的特性提供了一个强大的工具，有助于实现面向切面的编程。</p>
<p>如果要对Java程序进行这种修改，我们需要在agent的premain方法上添加类型为Instrumentation的第二个参数。Instrumentation参数可以用来执行一系列的任务，比如确定对象以字节为单位的精确大小以及通过注册ClassFileTransformers实际修改类的实现。ClassFileTransformers注册之后，当类加载器（class loader）加载类的时候都会调用它。当它被调用时，在类文件所代表的类加载之前，类文件transformer有机会改变或完全替换这个类文件。按照这种方式，在类使用之前，我们能够增强或修改类的行为，如下面的样例所示：</p>
<p>public class Agent { public static void premain(String argument, Instrumentation inst) {   inst.addTransformer(new ClassFileTransformer() {     @Override     public byte[] transform(       ClassLoader loader,       String className,       Class&lt;?&gt; classBeingRedefined, // 如果类之前没有加载的话，值为null       ProtectionDomain protectionDomain,       byte[] classFileBuffer) {       // 返回改变后的类文件。     }   }); }}</p>
<p>通过使用Instrumentation实例注册上述的ClassFileTransformer之后，每个类加载的时候，都会调用这个transformer。为了实现这一点，transformer会接受一个二进制和类加载器的引用，分别代表了类文件以及试图加载类的类加载器。</p>
<p>Java agent也可以在Java应用的运行期注册，如果是在这种场景下，instrumentation API允许重新定义已加载的类，这个特性被称之为“HotSwap”。不过，重新定义类仅限于替换方法体。在重新定义类的时候，不能新增或移除类成员，并且类型和签名也不能进行修改。当类第一次加载的时候，并没有这种限制，如果是在这样的场景下，那classBeingRedefined会被设置为null。</p>
<p>Java字节码与类文件格式</p>
<p>类文件代表了Java类编译之后的状态。类文件中会包含字节码，这些字节码代表了Java源码中最初的程序指令。Java字节码可以视为Java虚拟机的语言。实际上，JVM并不会将Java视为编程语言，它只能处理字节码。因为它采用二进制的表现形式，所以相对于程序的源码，它占用的空间更少。除此之外，将程序以字节码的形式进行表现能够更容易地编译Java以外的其他语言，如Scala或Clojure，从而让它们运行在JVM上。如果没有字节码作为中间语言的话，那么其他的程序在运行之前，可能还需要将其转换为Java源码。</p>
<p>但是，在代码处理的时候，这种抽象却带来了一定的成本。如果要将ClassFileTransformer应用到某个类上，那我们不能将该类按照Java源码的形式进行处理，甚至不能假设被转换的代码最初是由Java编写而成的。更糟糕的是，探查类成员或注解的反射API也是禁止使用的，这是因为类加载之前，我们无法访问这些API，而在转换进程完成之前，是无法进行加载的。</p>
<p>所幸的是，Java字节码相对来讲是一个比较简单的抽象形式，它包含了很少量的操作，稍微花点功夫我们就能大致将其掌握起来。Java虚拟机执行程序的时候，会以基于栈的方式来处理值。字节码指令一般会告知虚拟机，需要从操作数栈（operand stack）上弹出值，执行一些操作，然后再将结果压到栈中。</p>
<p>让我们考虑一个简单的样例：将数字1和2进行相加操作。JVM首先会将这两个数字压到栈中，这是通过 iconst_1和iconst_2这两个字节指令实现的。iconst_1是个单字节的便捷运算符（operator），它会将数字1压到栈中。与之类似，iconst_2会将数字2压到栈中。然后，会执行iadd指令，它会将栈中最新的两个值弹出，将它们求和计算的结果重新压到栈中。在类文件中，每个指令并不是以其易于记忆的名称进行存储的，而是以一个字节的形式进行存储，这个字节能够唯一地标记特定的指令，这也是bytecode这个术语的来历。上文所述的字节码指令及其对操作数栈的影响，通过下面的图片进行了可视化。</p>
<p><img src="\images\pasted-54.png" alt="upload successful"></p>
<p>对于人类用户来讲，会更喜欢源码而不是字节码，不过幸运的是Java社区创建了多个库，能够解析类文件并将紧凑的字节码暴露为具有名称的指令流。例如，流行的ASM库提供了一个简单的visitor API，它能够将类文件剖析为成员和方法指令，其操作方式类似于阅读XML文件时的SAX解析器。如果使用ASM的话，那上述样例中的字节码可以按照如下的代码来进行实现（在这里，ASM方式的指令是visitIns，能够提供修正的方法实现）：</p>
<p>MethodVisitor methodVisitor = …methodVisitor.visitIns(Opcodes.ICONST_1);methodVisitor.visitIns(Opcodes.ICONST_2);methodVisitor.visitIns(Opcodes.IADD);</p>
<p>需要注意的是，字节码规范只不过是一种比喻的说法（metaphor），因为Java虚拟机允许将程序转换为优化后的机器码（machine code），只要程序的输出能够保证是正确的即可。因为字节码的简洁性，所以在已有的类中取代和修改指令是很简单直接的。因此，使用ASM及其底层的Java字节码基础就足以实现类转换的Java agent，这需要注册一个ClassFileTransformer，它会使用这个库来处理其参数。</p>
<p>克服字节码的不足</p>
<p>对于实际的应用来讲，解析原始的类文件依然意味着有很多的手动工作。Java程序员通常感兴趣的是类型层级结构中的类。例如，某个Java agent可能需要修改所有实现给定接口的类。如果要确定某个类的超类，那只靠解析ClassFileTransformer所给定的类文件就不够了，类文件中只包含了直接超类和接口的名字。为了解析可能的超类型关联关系，程序员依然需要定位这些类型的类文件。</p>
<p>在项目中直接使用ASM的另外一个困难在于，团队中需要有开发人员学习Java字节码的基础知识。在实践中，这往往会导致很多的开发人员不敢再去修改字节码操作相关的代码。如果这样的话，实现Java agent很容易为项目的长期维护带来风险。</p>
<p>为了克服这些问题，我们最好使用较高层级的抽象来实现Java agent，而不是直接操作Java字节码。Byte Buddy是开源的、基于Apache 2.0许可证的库，它致力于解决字节码操作和instrumentation API的复杂性。Byte Buddy所声称的目标是将显式的字节码操作隐藏在一个类型安全的领域特定语言背后。通过使用Byte Buddy，任何熟悉Java编程语言的人都有望非常容易地进行字节码操作。</p>
<p>Byte Buddy简介</p>
<p>Byte Buddy的目的并不仅仅是为了生成Java agent。它提供了一个API用于生成任意的Java类，基于这个生成类的API，Byte Buddy提供了额外的API来生成Java agent。</p>
<p>作为Byte Buddy的简介，如下的样例展现了如何生成一个简单的类，这个类是Object的子类，并且重写了toString方法，用来返回“Hello World!”。与原始的ASM类似，“intercept”会告诉Byte Buddy为拦截到的指令提供方法实现：</p>
<p>Class&lt;?&gt; dynamicType = new ByteBuddy()  .subclass(Object.class)  .method(ElementMatchers.named(“toString”))  .intercept(FixedValue.value(“Hello World!”))  .make()  .load(getClass().getClassLoader(),                  ClassLoadingStrategy.Default.WRAPPER)  .getLoaded();</p>
<p>从上面的代码中，我们可以看到Byte Buddy要实现一个方法分为两步。首先，编程人员需要指定一个ElementMatcher，它负责识别一个或多个需要实现的方法。Byte Buddy提供了功能丰富的预定义拦截器（interceptor），它们暴露在ElementMatchers类中。在上述的例子中，toString方法完全精确匹配了名称，但是，我们也可以匹配更为复杂的代码结构，如类型或注解。</p>
<p>当Byte Buddy生成类的时候，它会分析所生成类型的类层级结构。在上述的例子中，Byte Buddy能够确定所生成的类要继承其超类Object的名为toString的方法，指定的匹配器会要求Byte Buddy重写该方法，这是通过随后的 Implementation 实例实现的，在我们的样例中，这个实例也就是FixedValue。</p>
<p>当创建子类的时候，Byte Buddy始终会拦截（intercept）一个匹配的方法，在生成的类中重写该方法。但是，我们在本文稍后将会看到Byte Buddy还能够重新定义已有的类，而不必通过子类的方式来实现。在这种情况下，Byte Buddy会将已有的代码替换为生成的代码，而将原有的代码复制到另外一个合成的（synthetic）方法中。</p>
<p>在我们上面的代码样例中，匹配的方法进行了重写，在实现里面，返回了固定的值“Hello World!”。intercept方法接受Implementation类型的参数，Byte Buddy自带了多个预先定义的实现，如上文所使用的FixedValue类。但是，如果需要的话，可以使用前文所述的ASM API将某个方法实现为自定义的字节码，Byte Buddy本身也是基于ASM API实现的。</p>
<p>定义完类的属性之后，就能通过make方法来进行生成。在样例应用中，因为用户没有指定类名，所以生成的类会给定一个任意的名称。最终，生成的类将会使用ClassLoadingStrategy来进行加载。通过使用上述的默认 WRAPPER策略，类将会使用一个新的类加载器进行加载，这个类加载器会使用环境类加载器作为父加载器。</p>
<p>类加载之后，使用Java反射API就可以访问它了。如果没有指定其他构造器的话，Byte Buddy将会生成类似于父类的构造器，因此生成的类可以使用默认的构造器。这样，我们就可以检验生成的类重写了 toString方法，如下面的代码所示：</p>
<p>assertThat(dynamicType.newInstance().toString(),            is(“Hello World!”));</p>
<p>当然，这个生成的类并没有太大的用处。对于实际的应用来讲，大多数方法的返回值是在运行时计算的，这个计算过程要依赖于方法的参数和对象的状态。</p>
<p>通过委托实现Instrumentation</p>
<p>要实现某个方法，有一种更为灵活的方式，那就是使用Byte Buddy的MethodDelegation。通过使用方法委托，在生成重写的实现时，我们就有可能调用给定类和实例的其他方法。按照这种方式，我们可以使用如下的委托器（delegator）重新编写上述的样例：</p>
<p>class ToStringInterceptor {  static String intercept() {    return “Hello World!”;  }}</p>
<p>借助上面的POJO拦截器，我们就可以将之前的FixedValue实现替换为MethodDelegation.to(ToStringInterceptor.class)：</p>
<p>Class&lt;?&gt; dynamicType = new ByteBuddy()  .subclass(Object.class)  .method(ElementMatchers.named(“toString”))  .intercept(MethodDelegation.to(ToStringInterceptor.class))  .make()  .load(getClass().getClassLoader(),                  ClassLoadingStrategy.Default.WRAPPER)  .getLoaded();</p>
<p>使用上述的委托器，Byte Buddy会在to方法所给定的拦截目标中，确定最优的调用方法。就ToStringInterceptor.class来讲，选择过程只是非常简单地解析这个类型的唯一静态方法而已。在本例中，只会考虑一个静态方法，因为委托的目标中指定的是一个类。与之不同的是，我们还可以将其委托给某个类的实例，如果是这样的话，Byte Buddy将会考虑所有的虚方法（virtual method）。如果类或实例上有多个这样的方法，那么Byte Buddy首先会排除掉所有与指定instrumentation不兼容的方法。在剩余的方法中，库将会选择最佳的匹配者，通常来讲这会是参数最多的方法。我们还可以显式地指定目标方法，这需要缩小合法方法的范围，将ElementMatcher传递到MethodDelegation中，就会进行方法的过滤。例如，通过添加如下的filter，Byte Buddy只会将名为“intercept”的方法视为委托目标：</p>
<p>MethodDelegation.to(ToStringInterceptor.class)                .filter(ElementMatchers.named(“intercept”))</p>
<p>执行上面的拦截之后，被拦截到的方法依然会打印出“Hello World!”，但是这次的结果是动态计算的，这样的话，我们就可以在拦截器方法上设置断点，所生成的类每次调用toString时，都会触发拦截器的方法。</p>
<p>当我们为拦截器方法设置参数时，就能释放出MethodDelegation的全部威力。这里的参数通常是带有注解的，用来要求Byte Buddy在调用拦截器方法时，注入某个特定的值。例如，通过使用@Origin注解，Byte Buddy提供了添加instrument功能的方法的实例，将其作为Java反射API中类的实例：</p>
<p>class ContextualToStringInterceptor {  static String intercept(@Origin Method m) {    return “Hello World from ” + m.getName() + “!”;  }}</p>
<p>当拦截toString方法时，对instrument方法的调用将会返回“Hello world from toString!”。</p>
<p>除了@Origin注解以外，Byte Buddy提供了一组功能丰富的注解。例如，通过在类型为Callable的参数上使用@Super注解，Byte Buddy会创建并注入一个代理实例，它能够调用被instrument方法的原始代码。如果对于特定的用户场景，所提供的注解不能满足需求或者不太适合的话，我们甚至能够注册自定义的注解，让这些注解注入用户特定的值。</p>
<p>实现方法级别的安全性</p>
<p>可以看到，我们在运行时可以借助简单的Java代码，使用MethodDelegation来动态重写某个方法。这只是一个简单的样例，但是这项技术可以用到更加实际的应用之中。在本文剩余的内容中，我们将会开发一个样例，它会使用代码生成技术实现一个注解驱动的库，用来限制方法级别的安全性。在我们的第一个迭代中，这个库会通过生成子类的方式来限制安全性。然后，我们将会采取相同的方式来实现Java agent，完成相同的功能。</p>
<p>样例库会使用如下的注解，允许用户指定某个方法需要考虑安全因素：</p>
<p>@interface Secured {  String user();}</p>
<p>例如，假设应用需要使用如下的Service类来执行敏感操作，并且只有用户被认证为管理员才能执行该方法。这是通过为执行这个操作的方法声明Secured注解来指定的：</p>
<p>class Service {  @Secured(user = “ADMIN”)  void doSensitiveAction() {    // 运行敏感代码…  }}</p>
<p>我们当然可以将安全检查直接编写到方法中。在实际中，硬编码横切关注点往往会导致复制-粘贴的逻辑，使其难以维护。另外，一旦应用需要涉及额外的需求时，如日志、收集调用指标或结果缓存，直接添加这样的代码扩展性不会很好。通过将这样的功能抽取到agent中，方法就能很纯粹地关注其业务逻辑，使得代码库能够更易于阅读、测试和维护。</p>
<p>为了让我们规划的库保持尽可能得简单，按照注解的协议声明，如果当前用户不具备注解的用户属性时，将会抛出IllegalStateException异常。通过使用Byte Buddy，这种行为可以用一个简单的拦截器来实现，如下面样例中的SecurityInterceptor所示，它会通过其静态的user域，跟踪当前用户已经进行了登录：</p>
<p>class SecurityInterceptor {  static String user = “ANONYMOUS”  static void intercept(@Origin Method method) {    if (!method.getAnnotation(Secured.class).user().equals(user)) {      throw new IllegalStateException(“Wrong user”);    }  }}</p>
<p>通过上面的代码，我们可以看到，即便给定用户授予了访问权限，拦截器也没有调用原始的方法。为了解决这个问题，Byte Buddy有很多预定义的方法可以实现功能的链接。借助MethodDelegation类的andThen方法，上述的安全检查可以放到原始方法的调用之前，如下面的代码所示。如果用户没有进行认证的话，安全检查将会抛出异常并阻止后续的执行，因此原始方法将不会执行。</p>
<p>将这些功能集合在一起，我们就能生成Service的一个子类，所有带有注解方法的都能恰当地进行安全保护。因为所生成的类是Service的子类，所以它能够替代所有类型为Service的变量，并不需要任何的类型转换，如果没有恰当认证的话，调用doSensitiveAction方法就会抛出异常：</p>
<p>new ByteBuddy()  .subclass(Service.class)  .method(ElementMatchers.isAnnotatedBy(Secured.class))  .intercept(MethodDelegation.to(SecurityInterceptor.class)                             .andThen(SuperMethodCall.INSTANCE)))  .make()  .load(getClass().getClassLoader(),           ClassLoadingStrategy.Default.WRAPPER)  .getLoaded()  .newInstance()  .doSensitiveAction();</p>
<p>不过坏消息是，因为实现instrumentation功能的子类是在运行时创建的，所以除了使用Java反射以外，没有其他办法创建这样的实例。因此，所有instrumentation类的实例都应该通过一个工厂来创建，这个工厂会封装创建instrumentation子类的复杂性。这样造成的结果就是，子类instrumentation通常会用于框架之中，这些框架本身就需要通过工厂来创建实例，例如，像依赖管理的框架Spring或对象-关系映射的框架Hibernate，而对于其他类型的应用来讲，子类instrumentation实现起来通常过于复杂。</p>
<p>实现安全功能的Java agent</p>
<p>通过使用Java agent，上述安全框架的一个替代实现将会修改Service类的原始字节码，而不是重写它。这样做的话，我们就没有必要创建托管的实例了，只需简单地调用</p>
<p>new Service().doSensitiveAction()</p>
<p>即可，如果对应的用户没有进行认证的话，就会抛出异常。为了支持这种方式，Byte Buddy提供一种称之为rebase某个类的理念。当rebase某个类的时候，不会创建子类，所采用的策略是实现instrumentation功能的代码将会合并到被instrument的类中，从而改变其行为。在添加instrumentation功能之后，在被instrument的类中，其所有方法的原始代码均可进行访问，因此像SuperMethodCall这样的instrumentation，工作方式与创建子类是完全一样的。</p>
<p>创建子类与rebase的行为是非常类似的，所以两种操作的API执行方式是一致的，都会使用相同的DynamicType.Builder接口来描述某个类型。两种形式的instrumentation都可以通过ByteBuddy类来进行访问。为了使Java agent的定义更加便利，Byte Buddy还提供了 AgentBuilder类，它希望能够以一种简洁的方式应对一些通用的用户场景。为了定义Java agent实现方法级别的安全性，将如下的类定义为agent的入口点就足以完成该功能了：</p>
<p>class SecurityAgent {  public static void premain(String arg, Instrumentation inst) {    new AgentBuilder.Default()    .type(ElementMatchers.any())    .transform((builder, type) -&gt; builder    .method(ElementMatchers.isAnnotatedBy(Secured.class)    .intercept(MethodDelegation.to(SecurityInterceptor.class)               .andThen(SuperMethodCall.INSTANCE))))    .installOn(inst);  }}</p>
<p>如果将这个agent打包为jar文件并在命令行中进行指定，那么所有带有Secured注解的方法将会进行“转换”或重定义，从而实现安全保护。如果不激活这个Java agent的话，应用在运行时就不包含额外的安全检查。当然，这意味着如果对带有注解的代码进行单元测试的话，这些方法的调用并不需要特殊的搭建过程来模拟安全上下文。Java运行时会忽略掉无法在classpath中找到的注解类型，因此在运行带有注解的方法时，我们甚至完全可以在应用中移除掉安全库。</p>
<p>另外一项优势在于，Java agent能够很容易地进行叠加。如果在命令行中指定多个Java agent的话，每个agent都有机会对类进行修改，其顺序就是在命令行中所指定的顺序。例如，我们可以采取这种方式将安全、日志以及监控框架联合在一起，而不需要在这些应用间增添任何形式的集成层。因此，使用Java agent实现横切的关注点提供了一种更为模块化的代码编写方式，而不必针对某个管理实例的中心框架来集成所有的代码。</p>
<p>查看英文原文：Easily Create Java Agents with Byte Buddy</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/09/10/zookeeper-%E5%8F%8D%E5%A4%8D%E9%87%8D%E8%BF%9E%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/10/zookeeper-%E5%8F%8D%E5%A4%8D%E9%87%8D%E8%BF%9E%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">zookeeper-反复重连问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-10 18:09:00" itemprop="dateCreated datePublished" datetime="2018-09-10T18:09:00+08:00">2018-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%99%E4%BA%9B%E5%B9%B4%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%9D%91/" itemprop="url" rel="index"><span itemprop="name">这些年，那些坑</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>482</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>现象，zk后台日志发现频繁刷如下日志<br>Refusing session request for client /192.168.46.4:48551 as it has seen zxid 0x3cdf3127 our last zxid is 0x5bba6c client must try another server</p>
<p>大量刷日志导致zk性能下降，最终导致依赖于zk的服务不可用</p>
<p>经分析：<br>日志来源代码为 org.apache.zookeeper.server.ZooKeeperServer</p>
<p><img src="\images\pasted-18.png" alt="upload successful"><br>lastProcessedZxid在zk中用于记录版本信息，即客户端与服务端版本控制</p>
<p>后经反馈得知，18.09.07由于snet环境zk日志量大，曾情况过zk数据目录数据，当时导致各应用zk不可用，要求各应用重启，后续大部分应用重启完成后业务正常使用，但并没有核对所有系统是否都重启</p>
<p>因此，部分没有重启的应用本地的版本信息还是老的信息，拿此信息与zk服务端交互，由于版本信息不对，导致zk拒绝连接，从而客户端又频繁发起重连尝试。。。</p>
<p>解决，一旦发起过zk数据目录删除，或者迁移，请务必确保所有应用全部重启以获取最新的版本信息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/09/10/jdk8-dump%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/10/jdk8-dump%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">jdk8-dump异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-10 10:36:00" itemprop="dateCreated datePublished" datetime="2018-09-10T10:36:00+08:00">2018-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%99%E4%BA%9B%E5%B9%B4%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%9D%91/" itemprop="url" rel="index"><span itemprop="name">这些年，那些坑</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>376</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="\images\pasted-1.png" alt="upload successful"><br>易极付代扣应用疑似存在内存泄漏，因此，尝试进行dump分析，后发现dump一直失败，报错如上，dump命令为：<br> jmap -F -dump:format=b,file=盘符:/XXX.hprof <pid></p>
<p>原因分析：<br><a target="_blank" rel="noopener" href="https://bugs.java.com/view_bug.do?bug_id=8044416">https://bugs.java.com/view_bug.do?bug_id=8044416</a></p>
<p>解决方案：<br>1、jmap -dump:format=b,file=盘符:/XXX.hprof <pid>，同时应用启动时，jvm参数-XX:+StartAttachListener<br>    use flag -XX:+StartAttachListener in target java process and make sure you run jmap within the same user as main java process</p>
<p>2、升级jdk版本到1.8.0_60以上8u60(Fixed)9b64(Fixed) </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/08/06/java-%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/06/java-%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">java-对象使用问题案例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-06 17:23:00" itemprop="dateCreated datePublished" datetime="2018-08-06T17:23:00+08:00">2018-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%99%E4%BA%9B%E5%B9%B4%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%9D%91/" itemprop="url" rel="index"><span itemprop="name">这些年，那些坑</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于java对象的使用，java编码的一个基本能力，但事实上，业务开发中，往往会有疏忽，下面从易极付支付引擎一个bug再次剖析java对象的使用。</p>
<p>业务场景：支付引擎转账-定时任务批量加载挂起的数据执行转账并异步回执<br>                1、批量查询挂起的转账数据，list<br>                2、循环遍历list执行转换并回执<br>                    2.1、将数据转换到业务上下文中<br>                    2.2、执行转账（数据从业务上下文中获取）<br>                    2.3、发布转账回执事件（数据从业务上下文中获取）<br>                 3、在新线程中异步回执（订阅到2.3发布的回执事件后与2并行执行）</p>
<p>上述是简化后的业务流程，下面加以核心代码说明支付引擎的实现逻辑<br>                1、批量查询挂起的转账数据，list </p>
<p><img src="\images\pasted-24.png" alt="upload successful"></p>
<p><img src="\images\pasted-25.png" alt="upload successful"><br> 2、循环遍历list执行转换并回执<br>     2.1、将数据转换到业务上下文中</p>
<p><img src="\images\pasted-26.png" alt="upload successful"></p>
<p><img src="\images\pasted-27.png" alt="upload successful"></p>
<p><img src="\images\pasted-28.png" alt="upload successful"><br>这儿调用的是易极付common-util中提供的对象转换方法，源码如下：</p>
<p><img src="\images\pasted-30.png" alt="upload successful"></p>
<p><img src="\images\pasted-31.png" alt="upload successful"></p>
<p> 2.2、执行转账（数据从业务上下文中获取）<br><img src="\images\pasted-32.png" alt="upload successful"></p>
<p>2.3、发布转账回执事件（数据从业务上下文中获取）<br><img src="\images\pasted-33.png" alt="upload successful"></p>
<p><img src="\images\pasted-34.png" alt="upload successful"></p>
<p><img src="\images\pasted-35.png" alt="upload successful"></p>
<p><img src="\images\pasted-36.png" alt="upload successful"></p>
<p><img src="\images\pasted-37.png" alt="upload successful"></p>
<p>3、在新线程中异步回执（订阅到2.3发布的回执事件后与2并行执行）<br><img src="\images\pasted-38.png" alt="upload successful"></p>
<p>上述逻辑，经过实际测试，存在严重问题，问题如下：<br>异步回执时，拿到的数据并不是实际预期的数据，而被篡改了，可以看见的是，执行异步回执时，拿到了list循环遍历后续的数据。</p>
<p>分析问题，很明显，我们看到了2.1这么一行代码：<br><img src="\images\pasted-39.png" alt="upload successful"><br>那么，当前2.2转账完成后，发出2.3异步回执事件，3执行回执是异步的（并行的），此时下一次循环完全可能已经再次执行了2.1这行代码，那么就有问题！！！  为什么？</p>
<p>上述判断只是初次分析，但经过进一步分析，我们发现其实3中的数据已经在2.3中将数据封装好，3只是从封装好的数据中取出相应的数据而已，2.3是同步执行过程，那么，下一次2.1执行时，一定是在上一次2.3执行完成之后！</p>
<p>但是，经测试，这儿确实是有问题的，<br>于是，再次分析：<br>2.1进行数据转换时，通过源码分析，我们得出，此处只是将数据的值一个一个的set到业务上下文的数据对象中，那么意味着什么？  业务上下午serviceContext是一个全局对象，进入执行逻辑前已经初始化完成，那么，其内存已经开辟完成，意味着该对象中数据对象的内存也已开辟完成。那么，set值只是为那一块内存进行了赋值操作<br>2.3通过getEntityObject将数据赋给新的对象I，那么，此时I和业务上下午中的数据对象都是指向同一块内存区域<br>3/2.1 此时3和下一个2.1并行执行，3中获取数据对象的值，而1.2给上下文数据对象赋予新的值， 那么，3是从这块内存区域取值，1.2是给这块内存区域赋值，一旦1.2执行在前，那么3拿到的当然是重新赋予的值。</p>
<p>通过上述分析，我们知道了问题根源，那么，如何改造？<br>很简单<br>修改2.1的代码为<br><img src="\images\pasted-40.png" alt="upload successful"></p>
<p><img src="\images\pasted-41.png" alt="upload successful"><br>很显然，同样是给业务上下午数据对象赋值，与上面的方案区别在于，此处是将上下午数据对象指向的新的内存地址。<br>那么执行2.3时，通过getEntityObject将数据赋给新的对象I，其所指向的内存地址也是这块新的地址<br>执行3/2.1时，3依旧从这块内存地址取值，而2.1则是将上下午数据对象指向另一块内存地址，毫不冲突，更谈不上数据篡改。</p>
<p>下面图示的方式给与说明：<br><img src="\images\pasted-42.png" alt="upload successful"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/07/30/%E6%95%B0%E6%8D%AE%E5%BA%93-kill%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/30/%E6%95%B0%E6%8D%AE%E5%BA%93-kill%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/" class="post-title-link" itemprop="url">数据库-kill服务进程引发的血案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-30 11:01:00" itemprop="dateCreated datePublished" datetime="2018-07-30T11:01:00+08:00">2018-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%99%E4%BA%9B%E5%B9%B4%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%9D%91/" itemprop="url" rel="index"><span itemprop="name">这些年，那些坑</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、问题描述：<br>18.07.27， 10：50分dba进行mysql数据库碎片整理，11：04分，发现数据库连接爆满，此时应用已处于down掉的状态，11：22数据库强行kill，11：40分之前发现应用并没有进行新的连接，此时停止应用发现停不下来，不得不kill掉应用进程，重启后恢复。但此时发现，之前入库的记录并没有成功，而mq由于没有收到应用的ack确认消息，消息重新进入队列并重发，加上数据没入库，交易进行了重复的操作！由于是全名抢车业务，导致重复上账，重复充退。</p>
<p>2、问题分析<br>由于没有及时的dump保护现场，加上应用down掉后，日志少的可怜，只有一些Broken pipe，以及该getOuptStream()异常，后期只能从代码层面分析。</p>
<p>3、分析<br>jdbc sockeTimeout时间并没有设置，所以默认使用的mysql的或者操作系统本身的socketTimeout 该问题会引发类似问题</p>
<p>相关文档:<br><a target="_blank" rel="noopener" href="http://www.sohu.com/a/142039227_505885">http://www.sohu.com/a/142039227_505885</a><br><a target="_blank" rel="noopener" href="http://www.sohu.com/a/141155649_539864?qq-pf-to=pcqq.c2c">http://www.sohu.com/a/141155649_539864?qq-pf-to=pcqq.c2c</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lx348321409/article/details/76095751">https://blog.csdn.net/lx348321409/article/details/76095751</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012944562">https://segmentfault.com/a/1190000012944562</a><br><a target="_blank" rel="noopener" href="https://www.cubrid.org/blog/understanding-jdbc-internals-and-timeout-configuration">https://www.cubrid.org/blog/understanding-jdbc-internals-and-timeout-configuration</a></p>
<p>=====================================================<br>jdbc timeout类别</p>
<p>主要有如下几个类别</p>
<p><img src="\images\pasted-16.png" alt="upload successful"><br>transaction timeout<br>设置的是一个事务的执行时间，里头可能包含多个statement<br>statement timeout(也相当于result set fetch timeout)<br>设置的是一个statement的执行超时时间，即driver等待statement执行完成，接收到数据的超时时间(注意statement的timeout不是整个查询的timeout，只是statement执行完成并拉取fetchSize数据返回的超时，之后resultSet的next在必要的时候还会触发fetch数据，每次fetch的超时时间是单独算的，默认也是以statement设置的timeout为准)<br>jdbc socket timeout<br>设置的是jdbc I/O socket read and write operations的超时时间，防止因网络问题或数据库问题，导致driver一直阻塞等待。(建议比statement timeout的时间长)<br>os socket timeout<br>这个是操作系统级别的socket设置(如果jdbc socket timeout没有设置，而os级别的socket timeout有设置，则使用系统的socket timeout值)。<br>上面的不同级别的timeout越往下优先级越高，也就是说如果下面的配置比上面的配置值小的话，则会优先触发timeout，那么相当于上面的配置值就”失效”了。<br>jdbc socket timeout</p>
<p>这个不同数据的jdbc driver实现不一样<br>mysql</p>
<p>jdbc:mysql://localhost:3306/ag_admin?useUnicode=true&amp;characterEncoding=UTF8&amp;connectTimeout=60000&amp;socketTimeout=60000<br>通过url参数传递即可<br>pg</p>
<p>jdbc:postgresql://localhost/test?user=fred&amp;password=secret&amp;&amp;connectTimeout=60&amp;socketTimeout=60<br>pg也是通过url传递，不过它的单位与mysql不同，mysql是毫秒，而pg是秒<br>oracle</p>
<p>oracle需要通过oracle.jdbc.ReadTimeout参数来设置，连接超时参数是oracle.net.CONNECT_TIMEOUT<br>通过properties设置<br>            Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>            Properties props = new Properties() ;<br>            props.put( “user” , “test_schema”) ;<br>            props.put( “password” , “pwd”) ;<br>            props.put( “oracle.net.CONNECT_TIMEOUT” , “10000000”) ;<br>            props.put( “oracle.jdbc.ReadTimeout” , “2000” ) ;<br>            Connection conn = DriverManager.getConnection( “jdbc:oracle:thin:@10.0.1.9:1521:orcl” , props ) ;<br>通过环境变量设置<br>String readTimeout = “10000”; // ms<br>System.setProperty(“oracle.jdbc.ReadTimeout”, readTimeout);<br>Class.forName(“oracle.jdbc.OracleDriver”);<br>Connection conn = DriverManager.getConnection(jdbcUrl, user, pwd);<br>注意需要在connection连接之前设置环境变量<br>tomcat jdbc pool<br>一般我们不直接使用jdbc connection，而是使用连接池。由于tomcat jdbc pool是springboot默认使用的数据库连接池，这里就讲述一下如何在tomcat jdbc pool下设置。<br>spring.datasource.tomcat.connectionProperties=oracle.net.CONNECT_TIMEOUT=10000;oracle.jdbc.ReadTimeout=60000<br>注意，这里是分号分隔，单位是毫秒，这里可以根据各自的情况配置前缀(tomcat jdbc连接池的话，默认是spring.datasource.tomcat)，可以自定义，比如<br>@Bean@Qualifier(“writeDataSource”)<br>    @ConfigurationProperties(prefix = “spring.datasource.write”)<br>    public DataSource writeDataSource() {<br>        returnDataSourceBuilder.create().build();<br>    }<br>假设你这里是自定义了prefix为spring.datasource.write，那么上述配置就变为<br>spring.datasource.write.connectionProperties=oracle.net.CONNECT_TIMEOUT=10000;oracle.jdbc.ReadTimeout=60000<br>oracle.jdbc.ReadTimeout如果没有设置的话，driver里头默认是0<br>oracle.jdbc.ReadTimeout</p>
<p>driver内部将该值设置到oracle.net.READ_TIMEOUT变量上<br>oracle.net.nt.TcpNTAdapter<br>    @Override<br>    publicvoid setReadTimeoutIfRequired(final Properties properties) throws IOException, NetException {<br>        String s = ((Hashtable&lt;K, String&gt;)properties).get(“oracle.net.READ_TIMEOUT”);<br>        if (s == null) {<br>            s = “0”;<br>        }<br>        this.setOption(3, s);<br>    }</p>
<pre><code>publicvoid setOption(int var1, Object var2) throws IOException, NetException &#123;
    String var3;
    switch(var1) &#123;
    case0:
        var3 = (String)var2;
        this.socket.setTcpNoDelay(var3.equals(&quot;YES&quot;));
        break;
    case1:
        var3 = (String)var2;
        if(var3.equals(&quot;YES&quot;)) &#123;
            this.socket.setKeepAlive(true);
        &#125;
    case2:
    default:
        break;
    case3:
        this.sockTimeout = Integer.parseInt((String)var2);
        this.socket.setSoTimeout(this.sockTimeout);
    &#125;

&#125;
</code></pre><p>可用看到最后设置的是socket的soTimeout<br>实例</p>
<pre><code>@Test
publicvoid testReadTimeout() throws SQLException &#123;
    Connection connection = dataSource.getConnection();
    String sql = &quot;select * from demo_table&quot;;
    PreparedStatement pstmt;
    try &#123;
        pstmt = (PreparedStatement)connection.prepareStatement(sql);
        ResultSet rs = pstmt.executeQuery();
        int col = rs.getMetaData().getColumnCount();
        System.out.println(&quot;============================&quot;);
        while (rs.next()) &#123;
            for (int i = 1; i &lt;= col; i++) &#123;
                System.out.print(rs.getObject(i));
            &#125;
            System.out.println(&quot;&quot;);
        &#125;
        System.out.println(&quot;============================&quot;);
    &#125; catch (SQLException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //close resources
    &#125;
&#125;
</code></pre><p>超时错误输出<br>//部分数据输出……<br>java.sql.SQLRecoverableException: IO 错误: Socket read timed out<br>    at oracle.jdbc.driver.T4CPreparedStatement.fetch(T4CPreparedStatement.java:1128)<br>    at oracle.jdbc.driver.OracleResultSetImpl.close_or_fetch_from_next(OracleResultSetImpl.java:373)<br>    at oracle.jdbc.driver.OracleResultSetImpl.next(OracleResultSetImpl.java:277)<br>    at com.example.demo.DemoApplicationTests.testReadTimeout(DemoApplicationTests.java:68)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>    at java.lang.reflect.Method.invoke(Method.java:497)<br>    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)<br>    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)<br>    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)<br>    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)<br>    at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)<br>    at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)<br>    at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)<br>    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)<br>    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252)<br>    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94)<br>    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)<br>    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)<br>    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)<br>    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)<br>    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)<br>    at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)<br>    at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)<br>    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)<br>    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191)<br>    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)<br>    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)<br>    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)<br>    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>    at java.lang.reflect.Method.invoke(Method.java:497)<br>    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)<br>Caused by: oracle.net.ns.NetException: Socket read timed out<br>    at oracle.net.ns.Packet.receive(Packet.java:339)<br>    at oracle.net.ns.DataPacket.receive(DataPacket.java:106)<br>    at oracle.net.ns.NetInputStream.getNextPacket(NetInputStream.java:315)<br>    at oracle.net.ns.NetInputStream.read(NetInputStream.java:260)<br>    at oracle.net.ns.NetInputStream.read(NetInputStream.java:185)<br>    at oracle.net.ns.NetInputStream.read(NetInputStream.java:102)<br>    at oracle.jdbc.driver.T4CSocketInputStreamWrapper.readNextPacket(T4CSocketInputStreamWrapper.java:124)<br>    at oracle.jdbc.driver.T4CSocketInputStreamWrapper.read(T4CSocketInputStreamWrapper.java:80)<br>    at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:1137)<br>    at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:290)<br>    at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:192)<br>    at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:531)<br>    at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:207)<br>    at oracle.jdbc.driver.T4CPreparedStatement.fetch(T4CPreparedStatement.java:1119)<br>    … 35 more<br>刚开始会有数据输出，但是到了某个resultSet的next的时候，报了超时(close_or_fetch_from_next)，这个超时指定的是当result.next方法触发新的一批数据的拉取(当一个fetchSize的数据消费完之后，接下来的next会触发新一批数据的fetch)之后在timeout时间返回内没有收到数据库返回的数据。<br>oracle的jdbc默认的fetchSize为10，也就是每个fetch，如果超过指定时间没接收到数据，则抛出timeout异常。<br>小结</p>
<p>jdbc的socketTimeout值的设置要非常小心，不同数据库的jdbc driver设置不一样，特别是使用不同连接池的话，设置也可能不尽相同。对于严重依赖数据库操作的服务来说，非常有必要设置这个值，否则万一网络或数据库异常，会导致服务线程一直阻塞在java.net.SocketInputStream.socketRead0。<br>如果查询数据多，则会导致该线程持有的data list不能释放，相当于内存泄露，最后导致OOM</p>
<h1 id="如果请求数据库操作很多且阻塞住了，会导致服务器可用的woker线程变少，严重则会导致服务不可用，nginx报504-Gateway-Timeout"><a href="#如果请求数据库操作很多且阻塞住了，会导致服务器可用的woker线程变少，严重则会导致服务不可用，nginx报504-Gateway-Timeout" class="headerlink" title="如果请求数据库操作很多且阻塞住了，会导致服务器可用的woker线程变少，严重则会导致服务不可用，nginx报504 Gateway Timeout"></a>如果请求数据库操作很多且阻塞住了，会导致服务器可用的woker线程变少，严重则会导致服务不可用，nginx报504 Gateway Timeout</h1><p>附：错误日志<br>org.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe<br>        at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:393)<br>        at org.apache.tomcat.util.buf.ByteChunk.flushBuffer(ByteChunk.java:426)<br>        at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:342)<br>        at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:317)<br>        at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:110)<br>        at org.springframework.session.web.http.OnCommittedResponseWrapper$SaveContextServletOutputStream.flush(OnCommittedResponseWrapper.java:437)<br>        at com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter.write(FastJsonHttpMessageConverter.java:216)<br>        at org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:183)<br>        at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:81)<br>        at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:126)<br>        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:832)<br>        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:743)<br>        at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)<br>        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:961)<br>        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:895)<br>        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:967)<br>        at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:858)<br>        at javax.servlet.http.HttpServlet.service(HttpServlet.java:687)<br>        at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:843)<br>        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at com.yjf.common.web.CrossScriptingFilter.doFilter(CrossScriptingFilter.java:120)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at com.yiji.boot.web.common.ResponseHeaderFilter.doFilterInternal(ResponseHeaderFilter.java:62)<br>        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at com.yiji.boot.actuator.acl.ActuatorACLFilter.doFilter(ActuatorACLFilter.java:36)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)<br>        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:121)<br>        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212)<br>        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)<br>        at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502)<br>        at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:676)<br>        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141)<br>        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)<br>        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)<br>        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:522)<br>        at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1095)<br>        at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672)<br>        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1502)<br>        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1458)<br>        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)<br>        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)<br>        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)<br>        at java.lang.Thread.run(Thread.java:745)<br>Caused by: java.io.IOException: Broken pipe<br>        at sun.nio.ch.FileDispatcherImpl.write0(Native Method)<br>        at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47)<br>        at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:93)<br>        at sun.nio.ch.IOUtil.write(IOUtil.java:65)<br>        at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:471)<br>        at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:124)<br>        at org.apache.tomcat.util.net.NioBlockingSelector.write(NioBlockingSelector.java:101)<br>        at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:172)<br>        at org.apache.coyote.http11.InternalNioOutputBuffer.writeToSocket(InternalNioOutputBuffer.java:139)<br>        at org.apache.coyote.http11.InternalNioOutputBuffer.addToBB(InternalNioOutputBuffer.java:197)<br>        at org.apache.coyote.http11.InternalNioOutputBuffer.access$000(InternalNioOutputBuffer.java:41)<br>        at org.apache.coyote.http11.InternalNioOutputBuffer$SocketOutputBuffer.doWrite(InternalNioOutputBuffer.java:320)<br>        at org.apache.coyote.http11.filters.ChunkedOutputFilter.doWrite(ChunkedOutputFilter.java:116)<br>        at org.apache.coyote.http11.AbstractOutputBuffer.doWrite(AbstractOutputBuffer.java:256)<br>        at org.apache.coyote.Response.doWrite(Response.java:501)<br>        at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:388)<br>        … 63 common frames omitted</p>
<p>2018-07-27 11:04:24.377 ERROR [http-nio-8313-exec-12] [dispatcherServlet]– Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.IllegalStateException: getOutputStream() has already been called for this response] with root cause<br>java.lang.IllegalStateException: getOutputStream() has already been called for this response<br>        at org.apache.catalina.connector.Response.getWriter(Response.java:564)<br>        at org.apache.catalina.connector.ResponseFacade.getWriter(ResponseFacade.java:212)<br>        at javax.servlet.ServletResponseWrapper.getWriter(ServletResponseWrapper.java:152)<br>        at javax.servlet.ServletResponseWrapper.getWriter(ServletResponseWrapper.java:152)<br>        at org.springframework.session.web.http.OnCommittedResponseWrapper.getWriter(OnCommittedResponseWrapper.java:133)<br>        at javax.servlet.ServletResponseWrapper.getWriter(ServletResponseWrapper.java:152)<br>        at org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration$SpelView.render(ErrorMvcAutoConfiguration.java:195)<br>        at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1246)<br>        at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1029)<br>        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:973)<br>        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:895)<br>        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:967)<br>        at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:858)<br>        at javax.servlet.http.HttpServlet.service(HttpServlet.java:687)<br>        at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:843)<br>        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at com.yjf.common.web.CrossScriptingFilter.doFilter(CrossScriptingFilter.java:92)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)<br>        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)<br>        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)<br>        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%87%8D%E5%90%AF%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E9%94%AE%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%87%8D%E5%90%AF%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E9%94%AE%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">数据库-重启引发的主键问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-22 12:04:00" itemprop="dateCreated datePublished" datetime="2018-07-22T12:04:00+08:00">2018-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%99%E4%BA%9B%E5%B9%B4%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%9D%91/" itemprop="url" rel="index"><span itemprop="name">这些年，那些坑</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>153</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>问题：cs系统 shut_message  自增主键id变小了。</p>
<p>原因：cs的数据库重启了，但是应用没停止，   mysql重启后，回滚了部分自增id，（亦或者是备库当主库用）</p>
<p>业务原因：本以为外网关闭了，定时任务关闭了 不会有交易<br>但是，  应用监控检查发邮件了，cs通过mq接收到了请求，连接数据库失败（此时数据库连接不上）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2018/07/19/rabbitmq-%E6%8A%A5not-equivalent%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/19/rabbitmq-%E6%8A%A5not-equivalent%E9%94%99/" class="post-title-link" itemprop="url">rabbitmq-报not equivalent错</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-19 17:28:00" itemprop="dateCreated datePublished" datetime="2018-07-19T17:28:00+08:00">2018-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-30 15:34:10" itemprop="dateModified" datetime="2019-09-30T15:34:10+08:00">2019-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%99%E4%BA%9B%E5%B9%B4%EF%BC%8C%E9%82%A3%E4%BA%9B%E5%9D%91/" itemprop="url" rel="index"><span itemprop="name">这些年，那些坑</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>818</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>问题：<br>支付引擎往monitor发送监控mq消息时，报错：<br>2018-07-19 15:54:35.423 ERROR [AMQP Connection 10.21.30.153:5672] CachingConnectionFactory– Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - parameters for queue ‘queue.monitor.logmsg’ in vhost ‘/‘ not equivalent, class-id=50, method-id=10)<br>Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - parameters for queue ‘queue.monitor.logmsg’ in vhost ‘/‘ not equivalent, class-id=50, method-id=10)</p>
<p>原因：<br>支付引擎使用monitor客户端发送mq消息，由如下逻辑：<br><img src="\images\pasted-43.png" alt="upload successful"></p>
<p><img src="\images\pasted-44.png" alt="upload successful"></p>
<p><img src="\images\pasted-45.png" alt="upload successful"></p>
<p><img src="\images\pasted-46.png" alt="upload successful"><br>问题出在：new Queue(XXX);<br>我们来看看参数：true、false、false。  但是mq服务器上当前的队列是monitor系统通过spring集成创建的，参数为：<br>false、false、true  同样的队列名，参数不一致，mq会报上述错误<br><img src="\images\pasted-47.png" alt="upload successful"></p>
<p><img src="\images\pasted-48.png" alt="upload successful"><br>解决方案：<br>合理的方案：保持参数一致<br>临时方案：停止monitor，这是队列自动删除了，启动支付引擎，创建队列，再启动monitor，因为monitor是采用spring方式创建队列，不会尝试重新创建</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiang Chuang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/realxc/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;realxc&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiang Chuang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">119k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
