<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文从spring对于线程池的实现ThreadPoolTaskExecutor入手阐述，由于该实现是对java的ThreadPoolExecutor进行了一次包装（扩展线程池能力），因此文中更多涉及到的是ThreadPoolExecutor关键实现逻辑的原理分析 1、executor = new ThreadPoolTaskExecutor();主要操作：父类CustomizableThreadC">
<meta property="og:type" content="article">
<meta property="og:title" content="剥开源码看java-线程池ThreadPoolExecutor">
<meta property="og:url" content="http://realxc.githut.io/2020/01/10/剥开源码看java/index.html">
<meta property="og:site_name" content="博客园-向闯">
<meta property="og:description" content="本文从spring对于线程池的实现ThreadPoolTaskExecutor入手阐述，由于该实现是对java的ThreadPoolExecutor进行了一次包装（扩展线程池能力），因此文中更多涉及到的是ThreadPoolExecutor关键实现逻辑的原理分析 1、executor = new ThreadPoolTaskExecutor();主要操作：父类CustomizableThreadC">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://realxc.githut.io/images/pasted-99.png">
<meta property="og:image" content="http://realxc.githut.io/images/pasted-103.png">
<meta property="og:updated_time" content="2020-01-10T08:37:23.456Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剥开源码看java-线程池ThreadPoolExecutor">
<meta name="twitter:description" content="本文从spring对于线程池的实现ThreadPoolTaskExecutor入手阐述，由于该实现是对java的ThreadPoolExecutor进行了一次包装（扩展线程池能力），因此文中更多涉及到的是ThreadPoolExecutor关键实现逻辑的原理分析 1、executor = new ThreadPoolTaskExecutor();主要操作：父类CustomizableThreadC">
<meta name="twitter:image" content="http://realxc.githut.io/images/pasted-99.png">





  
  
  <link rel="canonical" href="http://realxc.githut.io/2020/01/10/剥开源码看java/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>剥开源码看java-线程池ThreadPoolExecutor | 博客园-向闯</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客园-向闯</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://realxc.githut.io/2020/01/10/剥开源码看java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xiang Chuang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客园-向闯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剥开源码看java-线程池ThreadPoolExecutor

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-01-10 10:30:00 / 修改时间：16:37:23" itemprop="dateCreated datePublished" datetime="2020-01-10T10:30:00+08:00">2020-01-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/你好，源码/" itemprop="url" rel="index"><span itemprop="name">你好，源码</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文从spring对于线程池的实现ThreadPoolTaskExecutor入手阐述，由于该实现是对java的ThreadPoolExecutor进行了一次包装（扩展线程池能力），因此文中更多涉及到的是ThreadPoolExecutor关键实现逻辑的原理分析<br><img src="/images/pasted-99.png" alt="upload successful"></p>
<p><img src="/images/pasted-103.png" alt="upload successful"><br>1、executor = new ThreadPoolTaskExecutor();主要操作：父类CustomizableThreadCreator构造函数初始化，默认threadNamePrefix为实现类名简称-<br>2、excutor参数设置并excutor.initialize();（该方法属于ExecutorConfigurationSupport），其中会调用抽象方法initializeExecutor，由ThreadPoolTaskExecutor实现。<br>该处除了下面要讨论的corePoolSize，maxPollSize，queueCapacity外，想先说一下keepAliveSeconds这个值，代表允许操作核心线程数部分的线程空闲多长时间（s）后shut down，如果初始化时设置了allowCoreThreadTimeOut（true），那么对核心线程数以内的空闲线程也会shut down，避免资源浪费。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected ExecutorService initializeExecutor(</span><br><span class="line">			ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">		//1、创建队列：最大容量&gt;0，创建有界阻塞队列LinkedBlockingQueue；否则创建SynchronousQueue，其内部只有包含一个元素，因此，需要线程池足够大，否则，会出现大量拒绝</span><br><span class="line">		BlockingQueue&lt;Runnable&gt; queue = createQueue(this.queueCapacity);</span><br><span class="line"></span><br><span class="line">		ThreadPoolExecutor executor;</span><br><span class="line">		if (this.taskDecorator != null) &#123;</span><br><span class="line">			executor = new ThreadPoolExecutor(</span><br><span class="line">					this.corePoolSize, this.maxPoolSize, this.keepAliveSeconds, TimeUnit.SECONDS,</span><br><span class="line">					queue, threadFactory, rejectedExecutionHandler) &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void execute(Runnable command) &#123;</span><br><span class="line">					super.execute(taskDecorator.decorate(command));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			executor = new ThreadPoolExecutor(</span><br><span class="line">					this.corePoolSize, this.maxPoolSize, this.keepAliveSeconds, TimeUnit.SECONDS,</span><br><span class="line">					queue, threadFactory, rejectedExecutionHandler);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (this.allowCoreThreadTimeOut) &#123;</span><br><span class="line">			executor.allowCoreThreadTimeOut(true);</span><br><span class="line">		&#125;</span><br><span class="line">		//2、创建java线程池ThreadPoolExcutor，即，ThreadPoolTaskExetor是对java线程池的包装</span><br><span class="line">		this.threadPoolExecutor = executor;</span><br><span class="line">		return executor;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、executor.execute(runnable);<br>通过源码分析，线程池中线程的初始化是在执行阶段根据实际情况初始化的，如果活跃线程小于核心线程则新开线程(及时由线程是空闲的)，否则尝试将任务压入队列等待执行，如果队列压满则尝试根据最大线程数控制来新开线程（小于最大线程数时可新开线程）。java也提供了预分配核心线程的方法，支持提前创建核心线程，prestartCoreThread。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;//1、如果work数量小于核心线程大小，则新增work并把该任务委派给此work</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        //2、如果work数量大于等于核心线程大小，同时活动中的线程小于被shutdown的线程（代表相对空闲），同时队列未满，则把该任务压入队列中</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        //3、如果活动中的线程大于被shutdown的线程（代表相对繁忙）或者队列已满，则新增work并把该任务委派给此work，数量受maxPoolSize控制</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p> addWorker(Runnable firstTask, boolean core){};<br> 该方法用于创建work并执行初始化任务或者队列中的任务。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">       retry:</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           int c = ctl.get();</span><br><span class="line">           int rs = runStateOf(c);//</span><br><span class="line"></span><br><span class="line">           // Check if queue empty only if necessary.</span><br><span class="line">           if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == null &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty()))</span><br><span class="line">               return false;</span><br><span class="line"></span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               int wc = workerCountOf(c);</span><br><span class="line">               if (wc &gt;= CAPACITY ||</span><br><span class="line">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                   return false;</span><br><span class="line">               if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                   break retry;</span><br><span class="line">               c = ctl.get();  // Re-read ctl</span><br><span class="line">               if (runStateOf(c) != rs)</span><br><span class="line">                   continue retry;</span><br><span class="line">               // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       boolean workerStarted = false;</span><br><span class="line">       boolean workerAdded = false;</span><br><span class="line">       Worker w = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           w = new Worker(firstTask);</span><br><span class="line">           final Thread t = w.thread;</span><br><span class="line">           if (t != null) &#123;</span><br><span class="line">               final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">               mainLock.lock();</span><br><span class="line">               try &#123;</span><br><span class="line">                   // Recheck while holding lock.</span><br><span class="line">                   // Back out on ThreadFactory failure or if</span><br><span class="line">                   // shut down before lock acquired.</span><br><span class="line">                   int rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                   if (rs &lt; SHUTDOWN ||</span><br><span class="line">                       (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                       if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                           throw new IllegalThreadStateException();</span><br><span class="line">                       workers.add(w);</span><br><span class="line">                       int s = workers.size();</span><br><span class="line">                       if (s &gt; largestPoolSize)</span><br><span class="line">                           largestPoolSize = s;</span><br><span class="line">                       workerAdded = true;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   mainLock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">               if (workerAdded) &#123;</span><br><span class="line">               //使用新建的work执行任务</span><br><span class="line">                   t.start();</span><br><span class="line">                   workerStarted = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (! workerStarted)</span><br><span class="line">               addWorkerFailed(w);</span><br><span class="line">       &#125;</span><br><span class="line">       return workerStarted;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   final void runWorker(Worker w) &#123;</span><br><span class="line">       Thread wt = Thread.currentThread();</span><br><span class="line">       Runnable task = w.firstTask;</span><br><span class="line">       w.firstTask = null;</span><br><span class="line">       w.unlock(); // allow interrupts</span><br><span class="line">       boolean completedAbruptly = true;</span><br><span class="line">       try &#123;</span><br><span class="line">       //执行当前任务或者从队列中获取任务执行</span><br><span class="line">           while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">               w.lock();</span><br><span class="line">               // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">               // if not, ensure thread is not interrupted.  This</span><br><span class="line">               // requires a recheck in second case to deal with</span><br><span class="line">               // shutdownNow race while clearing interrupt</span><br><span class="line">               if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                   !wt.isInterrupted())</span><br><span class="line">                   wt.interrupt();</span><br><span class="line">               try &#123;</span><br><span class="line">                   beforeExecute(wt, task);</span><br><span class="line">                   Throwable thrown = null;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       task.run();</span><br><span class="line">                   &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                       thrown = x; throw x;</span><br><span class="line">                   &#125; catch (Error x) &#123;</span><br><span class="line">                       thrown = x; throw x;</span><br><span class="line">                   &#125; catch (Throwable x) &#123;</span><br><span class="line">                       thrown = x; throw new Error(x);</span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                       afterExecute(task, thrown);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   task = null;</span><br><span class="line">                   w.completedTasks++;</span><br><span class="line">                   w.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           completedAbruptly = false;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           processWorkerExit(w, completedAbruptly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">    * Performs blocking or timed wait for a task, depending on</span><br><span class="line">    * current configuration settings, or returns null if this worker</span><br><span class="line">    * must exit because of any of:</span><br><span class="line">    * 1. There are more than maximumPoolSize workers (due to</span><br><span class="line">    *    a call to setMaximumPoolSize).</span><br><span class="line">    * 2. The pool is stopped.</span><br><span class="line">    * 3. The pool is shutdown and the queue is empty.</span><br><span class="line">    * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="line">    *    workers are subject to termination (that is,</span><br><span class="line">    *    &#123;@code allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="line">    *    both before and after the timed wait, and if the queue is</span><br><span class="line">    *    non-empty, this worker is not the last thread in the pool.</span><br><span class="line">    *</span><br><span class="line">    * @return task, or null if the worker must exit, in which case</span><br><span class="line">    *         workerCount is decremented</span><br><span class="line">    */</span><br><span class="line">   private Runnable getTask() &#123;</span><br><span class="line">       boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           int c = ctl.get();</span><br><span class="line">           int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           // Check if queue empty only if necessary.</span><br><span class="line">           if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           // Are workers subject to culling?</span><br><span class="line">           boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">           if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">               if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   return null;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">           //poll()为非阻塞方法,如果当前队列为空,超时候，直接返回，超时返回时，返回的为null，此时会在runWorker后续方法中调用processWorkerExit，从而实现了对超过数量（大于核心线程，或者允许核心线程超时后回收）的线程超时后回收</span><br><span class="line">           //take()为阻塞方法,如果当前队列为空,则阻塞线程,封装线程到AQS的条件变量的条件队列中</span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               if (r != null)</span><br><span class="line">                   return r;</span><br><span class="line">               timedOut = true;</span><br><span class="line">           &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">       if (completedAbruptly) // If abrupt, then workerCount wasn&apos;t adjusted</span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">       final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">           //当前任务及队列中的任务执行完成后，移除当前work</span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tryTerminate();</span><br><span class="line"></span><br><span class="line">       int c = ctl.get();</span><br><span class="line">       if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">           if (!completedAbruptly) &#123;</span><br><span class="line">               int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">               if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                   min = 1;</span><br><span class="line">               if (workerCountOf(c) &gt;= min)</span><br><span class="line">                   return; // replacement not needed</span><br><span class="line">           &#125;</span><br><span class="line">           //如果剩余wrok数量小于核心线程大小（注意，如果设置了allowCoreThreadTimeOut，那么线程池不会保持最低核心线程数个线程），新建work</span><br><span class="line">           addWorker(null, false);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">    * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="line">    * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="line">    * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="line">    * idle worker to ensure that shutdown signals propagate. This</span><br><span class="line">    * method must be called following any action that might make</span><br><span class="line">    * termination possible -- reducing worker count or removing tasks</span><br><span class="line">    * from the queue during shutdown. The method is non-private to</span><br><span class="line">    * allow access from ScheduledThreadPoolExecutor.</span><br><span class="line">    */</span><br><span class="line">   final void tryTerminate() &#123;</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           int c = ctl.get();</span><br><span class="line">           if (isRunning(c) ||</span><br><span class="line">               runStateAtLeast(c, TIDYING) ||</span><br><span class="line">               (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">               return;</span><br><span class="line">           if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">               interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           try &#123;</span><br><span class="line">               if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       terminated();</span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                       ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                       termination.signalAll();</span><br><span class="line">                   &#125;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           // else retry on failed CAS</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">    * Interrupts threads that might be waiting for tasks (as</span><br><span class="line">    * indicated by not being locked) so they can check for</span><br><span class="line">    * termination or configuration changes. Ignores</span><br><span class="line">    * SecurityExceptions (in which case some threads may remain</span><br><span class="line">    * uninterrupted).</span><br><span class="line">    *</span><br><span class="line">    * @param onlyOne If true, interrupt at most one worker. This is</span><br><span class="line">    * called only from tryTerminate when termination is otherwise</span><br><span class="line">    * enabled but there are still other workers.  In this case, at</span><br><span class="line">    * most one waiting worker is interrupted to propagate shutdown</span><br><span class="line">    * signals in case all threads are currently waiting.</span><br><span class="line">    * Interrupting any arbitrary thread ensures that newly arriving</span><br><span class="line">    * workers since shutdown began will also eventually exit.</span><br><span class="line">    * To guarantee eventual termination, it suffices to always</span><br><span class="line">    * interrupt only one idle worker, but shutdown() interrupts all</span><br><span class="line">    * idle workers so that redundant workers exit promptly, not</span><br><span class="line">    * waiting for a straggler task to finish.</span><br><span class="line">    */</span><br><span class="line">   private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">       final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           for (Worker w : workers) &#123;</span><br><span class="line">               Thread t = w.thread;</span><br><span class="line">               //中断所有空闲线程，由于在runWorker中，活跃线程上锁了w.lock();，因此此处实现了只会终止空闲线程的效果</span><br><span class="line">               if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       t.interrupt();</span><br><span class="line">                   &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                       w.unlock();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (onlyOne)</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 4、动态调整线程池大小，由于业务需要，很多场景下，需要在运行时动态调整核心线程或最大线程的大小<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Sets the core number of threads.  This overrides any value set</span><br><span class="line">    * in the constructor.  If the new value is smaller than the</span><br><span class="line">    * current value, excess existing threads will be terminated when</span><br><span class="line">    * they next become idle.  If larger, new threads will, if needed,</span><br><span class="line">    * be started to execute any queued tasks.</span><br><span class="line">    *</span><br><span class="line">    * @param corePoolSize the new core size</span><br><span class="line">    * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125;</span><br><span class="line">    * @see #getCorePoolSize</span><br><span class="line">    */</span><br><span class="line">   public void setCorePoolSize(int corePoolSize) &#123;</span><br><span class="line">       if (corePoolSize &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException();</span><br><span class="line">       int delta = corePoolSize - this.corePoolSize;</span><br><span class="line">       this.corePoolSize = corePoolSize;</span><br><span class="line">       if (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">       //中断所有空闲线程，由于在runWorker中，活跃线程上锁了，因此此处实现了只会终止空闲线程的效果</span><br><span class="line">           interruptIdleWorkers();</span><br><span class="line">       else if (delta &gt; 0) &#123;</span><br><span class="line">           // We don&apos;t really know how many new threads are &quot;needed&quot;.</span><br><span class="line">           // As a heuristic, prestart enough new workers (up to new</span><br><span class="line">           // core size) to handle the current number of tasks in</span><br><span class="line">           // queue, but stop if queue becomes empty while doing so.</span><br><span class="line">           int k = Math.min(delta, workQueue.size());</span><br><span class="line">           while (k-- &gt; 0 &amp;&amp; addWorker(null, true)) &#123;</span><br><span class="line">               if (workQueue.isEmpty())</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/25/grafana安装及使用/" rel="next" title="grafana安装及使用">
                <i class="fa fa-chevron-left"></i> grafana安装及使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Xiang Chuang</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">53</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/realxc" title="GitHub &rarr; https://github.com/realxc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/709257360@qq.com@gmail.com" title="E-Mail &rarr; 709257360@qq.com@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiang Chuang</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>



  
  



  
  



  
  







  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/three/three.min.js"></script>

  
  <script src="/lib/three/three-waves.min.js"></script>

  
  <script src="/lib/three/canvas_lines.min.js"></script>

  
  <script src="/lib/three/canvas_sphere.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
